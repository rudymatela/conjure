sum :: [Int] -> Int
-- testing 3 combinations of argument values
-- pruning with 4/8 rules
-- 1 candidates of size 1
-- 1 candidates of size 2
-- 0 candidates of size 3
-- 1 candidates of size 4
-- 1 candidates of size 5
-- tested 4 candidates
sum []  =  0
sum (x:xs)  =  x + sum xs

app :: [Int] -> [Int] -> [Int]
-- testing 3 combinations of argument values
-- pruning with 0/0 rules
-- 2 candidates of size 1
-- 2 candidates of size 2
-- 1 candidates of size 3
-- 10 candidates of size 4
-- 12 candidates of size 5
-- 14 candidates of size 6
-- tested 32 candidates
app xs []  =  xs
app xs (x:ys)  =  x:app xs ys

mem :: Int -> [Int] -> Bool
-- testing 5 combinations of argument values
-- pruning with 29/42 rules
-- 1 candidates of size 1
-- 0 candidates of size 2
-- 0 candidates of size 3
-- 1 candidates of size 4
-- 0 candidates of size 5
-- 0 candidates of size 6
-- 0 candidates of size 7
-- 12 candidates of size 8
-- tested 13 candidates
mem x []  =  False
mem x (y:xs)  =  mem x xs || x == y

sub :: [Int] -> [Int] -> Bool
-- testing 9 combinations of argument values
-- pruning with 29/42 rules
-- 2 candidates of size 1
-- 4 candidates of size 2
-- 6 candidates of size 3
-- 1 candidates of size 4
-- 18 candidates of size 5
-- 7 candidates of size 6
-- 26 candidates of size 7
-- 95 candidates of size 8
-- 228 candidates of size 9
-- 191 candidates of size 10
-- 954 candidates of size 11
-- 957 candidates of size 12
-- 4260 candidates of size 13
-- 2687 candidates of size 14
-- 17846 candidates of size 15
-- tested 25802 candidates
sub [] xs  =  True
sub (x:xs) []  =  False
sub (x:xs) (y:ys)  =  sub xs ys && (sub (x:xs) ys || x == y)

set :: [Int] -> Bool
-- testing 8 combinations of argument values
-- pruning with 15/19 rules
-- 0 candidates of size 1
-- 0 candidates of size 2
-- 0 candidates of size 3
-- 2 candidates of size 4
-- 1 candidates of size 5
-- 1 candidates of size 6
-- 3 candidates of size 7
-- 5 candidates of size 8
-- tested 11 candidates
set []  =  True
set (x:xs)  =  set xs && not (elem x xs)

take :: Int -> [A] -> [A]
-- testing 143 combinations of argument values
-- pruning with 4/7 rules
-- 2 candidates of size 1
-- 3 candidates of size 2
-- 4 candidates of size 3
-- 6 candidates of size 4
-- 8 candidates of size 5
-- 13 candidates of size 6
-- 24 candidates of size 7
-- 31 candidates of size 8
-- 59 candidates of size 9
-- tested 111 candidates
take 0 xs  =  []
take x []  =  []
take x (y:xs)  =  y:take (x - 1) xs

drop :: Int -> [A] -> [A]
-- testing 143 combinations of argument values
-- pruning with 4/7 rules
-- 2 candidates of size 1
-- 3 candidates of size 2
-- 4 candidates of size 3
-- 4 candidates of size 4
-- 4 candidates of size 5
-- 4 candidates of size 6
-- 12 candidates of size 7
-- tested 24 candidates
drop 0 xs  =  xs
drop x []  =  []
drop x (y:xs)  =  drop (x - 1) xs

